//
// Generated by DslGenerator from Elucidator. Do not edit directly!!!
//
package me.omico.elucidator

import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.TypeName
import kotlin.Annotation
import kotlin.Any
import kotlin.Deprecated
import kotlin.String
import kotlin.Unit
import kotlin.collections.Iterable
import kotlin.reflect.KClass

@ElucidatorDsl
public interface FunctionScope {
  public val builder: FunSpec.Builder

  public fun build(): FunSpec
}

internal class FunctionBuilder(
  override val builder: FunSpec.Builder,
) : FunctionScope {
  override fun build(): FunSpec = builder.build()
}

public fun FunctionScope.addComment(format: String, vararg args: Any) {
  builder.addComment(format = format, args = args)
}

public fun FunctionScope.addStatement(format: String, vararg args: Any) {
  builder.addStatement(format = format, args = args)
}

public fun FunctionScope.addCode(format: String, vararg args: Any?) {
  builder.addCode(format = format, args = args)
}

public fun FunctionScope.addCode(codeBlock: CodeBlock) {
  builder.addCode(codeBlock = codeBlock)
}

public fun FunctionScope.addKdoc(format: String, vararg args: Any) {
  builder.addKdoc(format = format, args = args)
}

public fun FunctionScope.addKdoc(block: CodeBlock) {
  builder.addKdoc(block = block)
}

public fun FunctionScope.addModifiers(modifiers: Iterable<KModifier>) {
  builder.addModifiers(modifiers = modifiers)
}

public fun FunctionScope.addModifiers(vararg modifiers: KModifier) {
  builder.addModifiers(modifiers = modifiers)
}

public fun FunctionScope.addParameter(parameterSpec: ParameterSpec) {
  builder.addParameter(parameterSpec = parameterSpec)
}

public fun FunctionScope.addParameter(
  name: String,
  type: TypeName,
  vararg modifiers: KModifier,
) {
  builder.addParameter(name = name, type = type, modifiers = modifiers)
}

public fun FunctionScope.addParameter(
  name: String,
  type: TypeName,
  modifiers: Iterable<KModifier>,
) {
  builder.addParameter(name = name, type = type, modifiers = modifiers)
}

public fun FunctionScope.addParameter(
  name: String,
  type: KClass<*>,
  vararg modifiers: KModifier,
) {
  builder.addParameter(name = name, type = type, modifiers = modifiers)
}

public fun FunctionScope.addParameter(
  name: String,
  type: KClass<*>,
  modifiers: Iterable<KModifier>,
) {
  builder.addParameter(name = name, type = type, modifiers = modifiers)
}

public fun FunctionScope.beginControlFlow(controlFlow: String, vararg args: Any) {
  builder.beginControlFlow(controlFlow = controlFlow, args = args)
}

public fun FunctionScope.nextControlFlow(controlFlow: String, vararg args: Any) {
  builder.nextControlFlow(controlFlow = controlFlow, args = args)
}

public fun FunctionScope.endControlFlow() {
  builder.endControlFlow()
}

public fun constructorFunction(block: FunctionScope.() -> Unit): FunSpec =
    FunSpec.constructorBuilder().applyDslBuilder(block).build()

public fun getterFunction(block: FunctionScope.() -> Unit): FunSpec =
    FunSpec.getterBuilder().applyDslBuilder(block).build()

public fun setterFunction(block: FunctionScope.() -> Unit): FunSpec =
    FunSpec.setterBuilder().applyDslBuilder(block).build()

public fun FunSpec.Builder.applyDslBuilder(builder: FunctionScope.() -> Unit): FunSpec.Builder =
    FunctionBuilder(this).apply(builder).builder

public fun FunctionScope.clearModifiers(): Unit = builder.modifiers.clear()

public fun FunctionScope.modifiers(vararg modifiers: KModifier) {
  clearModifiers()
  addModifiers(modifiers = modifiers)
}

public fun FunctionScope.modifiers(modifiers: Iterable<KModifier>) {
  clearModifiers()
  addModifiers(modifiers = modifiers)
}

public fun FunctionScope.modifier(modifier: KModifier): Unit = modifiers(modifier)

@Deprecated(
  message =
      "In Elucidator, we use the `addAnnotation` function to create new annotations. Use the `annotate` function instead.",
  replaceWith = ReplaceWith("annotate(annotationSpec)"),
  level = DeprecationLevel.WARNING,
)
public fun FunctionScope.addAnnotation(annotationSpec: AnnotationSpec) {
  builder.addAnnotation(annotationSpec = annotationSpec)
}

@Deprecated(
  message =
      "In Elucidator, we use the `addAnnotation` function to create new annotations. Use the `annotate` function instead.",
  replaceWith = ReplaceWith("annotate(annotationSpecs)"),
  level = DeprecationLevel.WARNING,
)
public fun FunctionScope.addAnnotations(annotationSpecs: Iterable<AnnotationSpec>) {
  builder.addAnnotations(annotationSpecs = annotationSpecs)
}

public inline fun <reified T : Annotation> FunctionScope.annotate(noinline
    block: AnnotationScope.() -> Unit) {
  annotation(type = T::class, block = block).let(this::annotate)
}

public fun FunctionScope.annotate(annotationSpec: AnnotationSpec) {
  builder.addAnnotation(annotationSpec = annotationSpec)
}

public fun FunctionScope.annotate(annotationSpecs: Iterable<AnnotationSpec>) {
  builder.addAnnotations(annotationSpecs = annotationSpecs)
}

public fun FunctionScope.annotate(vararg annotationSpecs: AnnotationSpec) {
  builder.addAnnotations(annotationSpecs = annotationSpecs.toList())
}

public fun FunctionScope.annotate(`annotation`: ClassName) {
  builder.addAnnotation(annotation = annotation)
}

public inline fun <reified T> FunctionScope.annotate() {
  builder.addAnnotation(annotation = T::class)
}
